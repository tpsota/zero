/*
 * (c) Copyright 2011-2014, Hewlett-Packard Development Company, LP
 */

/**
 * Logging and its UNDO/REDO code for BTrees.
 * Separated from logrec.cpp.
 */

#include "btree_logrec.h"
#include "vol.h"
#include "bf_tree_cb.h"

btree_insert_t::btree_insert_t(
    const btree_page_h&   _page,
    const w_keystr_t&     key,
    const cvec_t&         el,
    const bool            is_sys_txn)
    : klen(key.get_length_as_keystr()), elen(el.size())
{
    root_shpid = _page.root();
    w_assert1((size_t)(klen + elen) < sizeof(data));
    key.serialize_as_keystr(data);
    el.copy_to(data + klen);
    sys_txn = is_sys_txn;
}

btree_insert_log::btree_insert_log(
    const btree_page_h& page,
    const w_keystr_t&   key,
    const cvec_t&       el,
    const bool          is_sys_txn)
{
    fill(page,
         (new (_data) btree_insert_t(page, key, el, is_sys_txn))->size());
}

void
btree_insert_log::undo(fixable_page_h* page) {
    w_assert9(page == 0);
    btree_insert_t* dp = (btree_insert_t*) data();

    if (true == dp->sys_txn)
    {
        // The insertion log record was generated by a page rebalance full logging operation
        // no 'undo' in this case
        return;
    }

    w_keystr_t key;
    key.construct_from_keystr(dp->data, dp->klen);

// TODO(Restart)...
DBGOUT3( << "&&&& UNDO insertion, key: " << key);

    // ***LOGICAL*** don't grab locks during undo
    W_COERCE(smlevel_0::bt->remove_as_undo(header._stid, key));
}

void
btree_insert_log::redo(fixable_page_h* page) {
    borrowed_btree_page_h bp(page);
    btree_insert_t* dp = (btree_insert_t*) data();

    w_assert1(bp.is_leaf());
    w_keystr_t key;
    vec_t el;
    key.construct_from_keystr(dp->data, dp->klen);
    el.put(dp->data + dp->klen, dp->elen);

// TODO(Restart)...
DBGOUT3( << "&&&& REDO insertion by replace ghost, key: " << key);

    // PHYSICAL redo
    // see btree_impl::_ux_insert()
    // at the point we called log_btree_insert,
    // we already made sure the page has a ghost
    // record for the key that is enough spacious.
    // so, we just replace the record!
    DBGOUT3( << "btree_insert_log::redo - key to replace ghost: " << key);
    w_rc_t rc = bp.replace_ghost(key, el);
    if(rc.is_error()) { // can't happen. wtf?
        W_FATAL_MSG(fcINTERNAL, << "btree_insert_log::redo " );
    }
}

btree_insert_nonghost_log::btree_insert_nonghost_log(
    const btree_page_h &page, const w_keystr_t &key, const cvec_t &el, const bool is_sys_txn) {
    fill(page,
        (new (_data) btree_insert_t(page, key, el, is_sys_txn))->size());
}

void btree_insert_nonghost_log::undo(fixable_page_h* page) {
    reinterpret_cast<btree_insert_log*>(this)->undo(page); // same as btree_insert
}

void btree_insert_nonghost_log::redo(fixable_page_h* page) {
    borrowed_btree_page_h bp(page);
    btree_insert_t* dp = reinterpret_cast<btree_insert_t*>(data());

    w_assert1(bp.is_leaf());
    w_keystr_t key;
    vec_t el;
    key.construct_from_keystr(dp->data, dp->klen);
    el.put(dp->data + dp->klen, dp->elen);

// TODO(Restart)...
DBGOUT3( << "&&&& REDO insertion, key: " << key);

    DBGOUT3( << "btree_insert_nonghost_log::redo - key to insert: " << key);
    bp.insert_nonghost(key, el);
}

btree_update_log::btree_update_log(
    const btree_page_h&   page,
    const w_keystr_t&     key,
    const char* old_el, int old_elen, const cvec_t& new_el)
{
    fill(page,
         (new (_data) btree_update_t(page, key, old_el, old_elen, new_el))->size());
}

void
btree_update_log::undo(fixable_page_h*)
{
    btree_update_t* dp = (btree_update_t*) data();

    w_keystr_t key;
    key.construct_from_keystr(dp->_data, dp->_klen);
    vec_t old_el;
    old_el.put(dp->_data + dp->_klen, dp->_old_elen);

    // ***LOGICAL*** don't grab locks during undo
    rc_t rc = smlevel_0::bt->update_as_undo(header._stid, key, old_el);
    if(rc.is_error()) {
        W_FATAL(rc.err_num());
    }
}

void
btree_update_log::redo(fixable_page_h* page)
{
    borrowed_btree_page_h bp(page);
    btree_update_t* dp = (btree_update_t*) data();

    w_assert1(bp.is_leaf());
    w_keystr_t key;
    key.construct_from_keystr(dp->_data, dp->_klen);
    vec_t old_el;
    old_el.put(dp->_data + dp->_klen, dp->_old_elen);
    vec_t new_el;
    new_el.put(dp->_data + dp->_klen + dp->_old_elen, dp->_new_elen);

    // PHYSICAL redo
    slotid_t       slot;
    bool           found;
    bp.search(key, found, slot);
    if (!found) {
        W_FATAL_MSG(fcINTERNAL, << "btree_update_log::redo(): not found");
        return;
    }
    w_rc_t rc = bp.replace_el_nolog(slot, new_el);
    if(rc.is_error()) { // can't happen. wtf?
        W_FATAL_MSG(fcINTERNAL, << "btree_update_log::redo(): couldn't replace");
    }
}

btree_overwrite_log::btree_overwrite_log (const btree_page_h& page, const w_keystr_t& key,
                                          const char* old_el, const char *new_el, size_t offset, size_t elen) {
    fill(page,
         (new (_data) btree_overwrite_t(page, key, old_el, new_el, offset, elen))->size());
}

void btree_overwrite_log::undo(fixable_page_h*)
{
    btree_overwrite_t* dp = (btree_overwrite_t*) data();

    uint16_t elen = dp->_elen;
    uint16_t offset = dp->_offset;
    w_keystr_t key;
    key.construct_from_keystr(dp->_data, dp->_klen);
    const char* old_el = dp->_data + dp->_klen;

    // ***LOGICAL*** don't grab locks during undo
    rc_t rc = smlevel_0::bt->overwrite_as_undo(header._stid, key, old_el, offset, elen);
    if(rc.is_error()) {
        W_FATAL(rc.err_num());
    }
}

void btree_overwrite_log::redo(fixable_page_h* page)
{
    borrowed_btree_page_h bp(page);
    btree_overwrite_t* dp = (btree_overwrite_t*) data();

    w_assert1(bp.is_leaf());

    uint16_t elen = dp->_elen;
    uint16_t offset = dp->_offset;
    w_keystr_t key;
    key.construct_from_keystr(dp->_data, dp->_klen);
    const char* new_el = dp->_data + dp->_klen + elen;

    // PHYSICAL redo
    slotid_t       slot;
    bool           found;
    bp.search(key, found, slot);
    if (!found) {
        W_FATAL_MSG(fcINTERNAL, << "btree_overwrite_log::redo(): not found");
        return;
    }

#if W_DEBUG_LEVEL>0
    const char* old_el = dp->_data + dp->_klen;
    smsize_t cur_elen;
    bool ghost;
    const char* cur_el = bp.element(slot, cur_elen, ghost);
    w_assert1(!ghost);
    w_assert1(cur_elen >= offset + elen);
    w_assert1(::memcmp(old_el, cur_el + offset, elen) == 0);
#endif //W_DEBUG_LEVEL>0

    bp.overwrite_el_nolog(slot, offset, new_el, elen);
}

btree_ghost_t::btree_ghost_t(const btree_page_h& p, const vector<slotid_t>& slots, const bool is_sys_txn)
{
    root_shpid = p.root();
    cnt = slots.size();
    if (true == is_sys_txn)
        sys_txn = 1;
    else
        sys_txn = 0;
    uint16_t *offsets = reinterpret_cast<uint16_t*>(slot_data);
    char *current = slot_data + sizeof (uint16_t) * slots.size();

    // the first data is prefix
    {
        uint16_t prefix_len = p.get_prefix_length();
        prefix_offset = (current - slot_data);
        // *reinterpret_cast<uint16_t*>(current) = prefix_len; this causes Bus Error on solaris! so, instead:
        ::memcpy(current, &prefix_len, sizeof(uint16_t));
        if (prefix_len > 0) {
            ::memcpy(current + sizeof(uint16_t), p.get_prefix_key(), prefix_len);
        }
        current += sizeof(uint16_t) + prefix_len;
    }

     for (size_t i = 0; i < slots.size(); ++i) {
        size_t len;
        w_assert3(p.is_leaf()); // ghost exists only in leaf
        const char* key = p._leaf_key_noprefix(slots[i], len);
        offsets[i] = (current - slot_data);
        // *reinterpret_cast<uint16_t*>(current) = len; this causes Bus Error on solaris! so, instead:
        uint16_t len_u16 = (uint16_t) len;
        ::memcpy(current, &len_u16, sizeof(uint16_t));
        ::memcpy(current + sizeof(uint16_t), key, len);
        current += sizeof(uint16_t) + len;
    }
    total_data_size = current - slot_data;
    w_assert0(logrec_t::max_data_sz >= sizeof(PageID) + sizeof(uint16_t) * 2  + sizeof(size_t) + total_data_size);
}
w_keystr_t btree_ghost_t::get_key (size_t i) const {
    w_keystr_t result;
    uint16_t prefix_len;
    // = *reinterpret_cast<const uint16_t*>(slot_data + prefix_offset); this causes Bus Error on solaris
    ::memcpy(&prefix_len, slot_data + prefix_offset, sizeof(uint16_t));
    w_assert1 (prefix_offset < sizeof(slot_data));
    w_assert1 (prefix_len < sizeof(slot_data));
    const char *prefix_key = slot_data + prefix_offset + sizeof(uint16_t);
    uint16_t offset = reinterpret_cast<const uint16_t*>(slot_data)[i];
    w_assert1 (offset < sizeof(slot_data));
    uint16_t len;
    // = *reinterpret_cast<const uint16_t*>(slot_data + offset); this causes Bus Error on solaris
    ::memcpy(&len, slot_data + offset, sizeof(uint16_t));
    w_assert1 (len < sizeof(slot_data));
    const char *key = slot_data + offset + sizeof(uint16_t);
    result.construct_from_keystr(prefix_key, prefix_len, key, len);
    return result;
}

btree_ghost_mark_log::btree_ghost_mark_log(const btree_page_h& p,
                                           const vector<slotid_t>& slots,
                                           const bool is_sys_txn)
{
    fill(p, (new (data()) btree_ghost_t(p, slots, is_sys_txn))->size());
}

void
btree_ghost_mark_log::undo(fixable_page_h*)
{
    // UNDO of ghost marking is to get the record back to regular state
    btree_ghost_t* dp = (btree_ghost_t*) data();

    if (1 == dp->sys_txn)
    {
        // The insertion log record was generated by a page rebalance full logging operation
        // no 'undo' in this case
        return;
    }

    for (size_t i = 0; i < dp->cnt; ++i) {
        w_keystr_t key (dp->get_key(i));

// TODO(Restart)...
DBGOUT3( << "&&&& UNDO deletion by remove ghost mark, key: " << key);

        rc_t rc = smlevel_0::bt->undo_ghost_mark(header._stid, key);
        if(rc.is_error()) {
            cerr << " key=" << key << endl << " rc =" << rc << endl;
            W_FATAL(rc.err_num());
        }
    }
}

void
btree_ghost_mark_log::redo(fixable_page_h *page)
{
    // REDO is physical. mark the record as ghost again.
    w_assert1(page);
    borrowed_btree_page_h bp(page);

    w_assert1(bp.is_leaf());
    btree_ghost_t* dp = (btree_ghost_t*) data();

    for (size_t i = 0; i < dp->cnt; ++i) {
        w_keystr_t key (dp->get_key(i));

            // If full logging, data movement log records are generated to remove records
            // from source, we set the new fence keys for source page in page_rebalance
            // log record which happens before the data movement log records.
            // Which means the source page might contain records which will be moved
            // out after the page_rebalance log records.  Do not validate the fence keys
            // if full logging

            // Assert only if minmal logging
            w_assert2(bp.fence_contains(key));

        bool found;
        slotid_t slot;

        bp.search(key, found, slot);
        // If doing page driven REDO, page_rebalance initialized the
        // target page (foster child).
        if (!found) {
            cerr << " key=" << key << endl << " not found in btree_ghost_mark_log::redo" << endl;
            w_assert1(false); // something unexpected, but can go on.
        }
        else
        {
            // TODO(Restart)...
            DBGOUT3( << "&&&& REDO deletion, not part of full logging, key: " << key);

            bp.mark_ghost(slot);
        }
    }
}

btree_ghost_reclaim_log::btree_ghost_reclaim_log(const btree_page_h& p,
                                                 const vector<slotid_t>& slots)
{
    // ghost reclaim is single-log system transaction. so, use data_ssx()
    fill(p, (new (data_ssx()) btree_ghost_t(p, slots, false))->size());
    w_assert0(is_single_sys_xct());
}

void
btree_ghost_reclaim_log::redo(fixable_page_h* page)
{
    // REDO is to defrag it again
    borrowed_btree_page_h bp(page);
    // TODO actually should reclaim only logged entries because
    // locked entries might have been avoided.
    // (but in that case shouldn't defragging the page itself be avoided?)
    rc_t rc = btree_impl::_sx_defrag_page(bp);
    if (rc.is_error()) {
        W_FATAL(rc.err_num());
    }
}

btree_ghost_reserve_t::btree_ghost_reserve_t(const w_keystr_t& key, int elem_length)
    : klen (key.get_length_as_keystr()), element_length (elem_length)
{
    key.serialize_as_keystr(data);
}

btree_ghost_reserve_log::btree_ghost_reserve_log (
    const btree_page_h& p, const w_keystr_t& key, int element_length) {
    // ghost creation is single-log system transaction. so, use data_ssx()
    fill(p, (new (data_ssx()) btree_ghost_reserve_t(key, element_length))->size());
    w_assert0(is_single_sys_xct());
}

void btree_ghost_reserve_log::redo(fixable_page_h* page) {
    // REDO is to physically make the ghost record
    borrowed_btree_page_h bp(page);
    // ghost creation is single-log system transaction. so, use data_ssx()
    btree_ghost_reserve_t* dp = (btree_ghost_reserve_t*) data_ssx();

    // PHYSICAL redo.
    w_assert1(bp.is_leaf());
    bp.reserve_ghost(dp->data, dp->klen, dp->element_length);
    w_assert3(bp.is_consistent(true, true));
}

/**
 * A \b multi-page \b SSX log record for \b btree_norec_alloc.
 * This log is totally \b self-contained, so no WOD assumed.
 */
btree_norec_alloc_t::btree_norec_alloc_t(const btree_page_h &p,
        PageID new_page_id, const w_keystr_t& fence, const w_keystr_t& chain_fence_high)
    : multi_page_log_t(new_page_id) {
    w_assert1 (g_xct()->is_single_log_sys_xct());
    w_assert1 (new_page_id != p.btree_root());
    w_assert1 (p.latch_mode() != LATCH_NL);

    _root_pid       = p.btree_root();
    _foster_pid     = p.get_foster();
    _foster_emlsn   = p.get_foster_emlsn();
    _fence_len      = (uint16_t) fence.get_length_as_keystr();
    _chain_high_len = (uint16_t) chain_fence_high.get_length_as_keystr();
    _btree_level    = (int16_t) p.level();
    w_assert1(size() < logrec_t::max_data_sz);

    fence.serialize_as_keystr(_data);
    chain_fence_high.serialize_as_keystr(_data + _fence_len);
}

btree_norec_alloc_log::btree_norec_alloc_log(const btree_page_h &p, const btree_page_h &,
    PageID new_page_id, const w_keystr_t& fence, const w_keystr_t& chain_fence_high) {
    fill(p, (new (data_ssx()) btree_norec_alloc_t(p,
        new_page_id, fence, chain_fence_high))->size());
}

void btree_norec_alloc_log::redo(fixable_page_h* p) {
    w_assert1(is_single_sys_xct());
    borrowed_btree_page_h bp(p);
    btree_norec_alloc_t *dp = reinterpret_cast<btree_norec_alloc_t*>(data_ssx());

    const lsn_t &new_lsn = lsn_ck();
    w_keystr_t fence, chain_high;
    fence.construct_from_keystr(dp->_data, dp->_fence_len);
    chain_high.construct_from_keystr(dp->_data + dp->_fence_len, dp->_chain_high_len);

    PageID target_pid = p->pid();
    DBGOUT3 (<< *this << ": new_lsn=" << new_lsn
        << ", target_pid=" << target_pid << ", bp.lsn=" << bp.get_page_lsn());
    if (target_pid == dp->_page2_pid) {
        // we are recovering "page2", which is foster-child.
        w_assert0(target_pid == dp->_page2_pid);
        // This log is also a page-allocation log, so redo the page allocation.
        W_COERCE(smlevel_0::vol->alloc_a_page(dp->_page2_pid, true /* redo */));
        PageID pid = dp->_page2_pid;
        // initialize as an empty child:
        bp.format_steal(new_lsn, pid, header._stid,
                        dp->_root_pid, dp->_btree_level, 0, lsn_t::null,
                        dp->_foster_pid, dp->_foster_emlsn, fence, fence, chain_high, false);
    } else {
        // we are recovering "page", which is foster-parent.
        bp.accept_empty_child(new_lsn, dp->_page2_pid, true /*from redo*/);
    }
}

/**
 * A \b multi-page \b SSX log record for \b btree_foster_adopt.
 * This log is totally \b self-contained, so no WOD assumed.
 */
btree_foster_adopt_t::btree_foster_adopt_t(PageID page2_id, PageID new_child_pid,
                        lsn_t new_child_emlsn, const w_keystr_t& new_child_key)
    : multi_page_log_t(page2_id), _new_child_emlsn(new_child_emlsn),
    _new_child_pid (new_child_pid) {
    _new_child_key_len = new_child_key.get_length_as_keystr();
    new_child_key.serialize_as_keystr(_data);
}

btree_foster_adopt_log::btree_foster_adopt_log (const btree_page_h& p, const btree_page_h& p2,
    PageID new_child_pid, lsn_t new_child_emlsn, const w_keystr_t& new_child_key) {
    fill(p, (new (data_ssx()) btree_foster_adopt_t(
        p2.pid(), new_child_pid, new_child_emlsn, new_child_key))->size());
}

void btree_foster_adopt_log::redo(fixable_page_h* p) {
    w_assert1(is_single_sys_xct());
    borrowed_btree_page_h bp(p);
    btree_foster_adopt_t *dp = reinterpret_cast<btree_foster_adopt_t*>(data_ssx());

    w_keystr_t new_child_key;
    new_child_key.construct_from_keystr(dp->_data, dp->_new_child_key_len);

    PageID target_pid = p->pid();
    DBGOUT3 (<< *this << " target_pid=" << target_pid << ", new_child_pid="
        << dp->_new_child_pid << ", new_child_key=" << new_child_key);
    if (target_pid == dp->_page2_pid) {
        // we are recovering "page2", which is real-child.
        w_assert0(target_pid == dp->_page2_pid);
        btree_impl::_ux_adopt_foster_apply_child(bp);
    } else {
        // we are recovering "page", which is real-parent.
        btree_impl::_ux_adopt_foster_apply_parent(bp, dp->_new_child_pid,
                                                  dp->_new_child_emlsn, new_child_key);
    }
}

btree_split_log::btree_split_log(
        const btree_page_h& child_p,
        const btree_page_h& parent_p,
        uint16_t move_count,
        const w_keystr_t& new_high_fence,
        const w_keystr_t& new_chain
)
{
    btree_bulk_delete_t* bulk =
        new (data_ssx()) btree_bulk_delete_t(parent_p.pid(),
                    child_p.pid(), move_count,
                    new_high_fence, new_chain);
    page_img_format_t* format = new (data_ssx() + bulk->size())
        page_img_format_t(child_p);

    // Logrec will have the child pid as main pid (i.e., destination page).
    // Parent pid is stored in btree_bulk_delete_t, which is a
    // multi_page_log_t (i.e., source page)
    fill(child_p, bulk->size() + format->size());
}

void btree_split_log::redo(fixable_page_h* p)
{
    btree_bulk_delete_t* bulk = (btree_bulk_delete_t*) data_ssx();
    page_img_format_t* format = (page_img_format_t*)
        (data_ssx() + bulk->size());

    if (p->pid() == bulk->new_foster_child) {
        // redoing the foster child
        format->apply(p);
    }
    else {
        // redoing the foster parent
        borrowed_btree_page_h bp(p);
        w_assert1(bp.nrecs() > bulk->move_count);
        bp.delete_range(bp.nrecs() - bulk->move_count, bp.nrecs());

        w_keystr_t new_high_fence, new_chain;
        bulk->get_keys(new_high_fence, new_chain);

        bp.set_foster_child(bulk->new_foster_child, new_high_fence, new_chain);
    }
}

btree_compress_page_log::btree_compress_page_log(
        const btree_page_h& page,
        const w_keystr_t& low,
        const w_keystr_t& high,
        const w_keystr_t& chain)
{
    uint16_t low_len = low.get_length_as_keystr();
    uint16_t high_len = high.get_length_as_keystr();
    uint16_t chain_len = chain.get_length_as_keystr();

    char* ptr = data_ssx();
    memcpy(ptr, &low_len, sizeof(uint16_t));
    ptr += sizeof(uint16_t);
    memcpy(ptr, &high_len, sizeof(uint16_t));
    ptr += sizeof(uint16_t);
    memcpy(ptr, &chain_len, sizeof(uint16_t));
    ptr += sizeof(uint16_t);

    low.serialize_as_keystr(ptr);
    ptr += low_len;
    high.serialize_as_keystr(ptr);
    ptr += high_len;
    chain.serialize_as_keystr(ptr);
    ptr += chain_len;

    fill(page, ptr - data_ssx());
}

void btree_compress_page_log::redo(fixable_page_h* p)
{
    char* ptr = data_ssx();

    uint16_t low_len = *((uint16_t*) ptr);
    ptr += sizeof(uint16_t);
    uint16_t high_len = *((uint16_t*) ptr);
    ptr += sizeof(uint16_t);
    uint16_t chain_len = *((uint16_t*) ptr);
    ptr += sizeof(uint16_t);

    w_keystr_t low, high, chain;
    low.construct_from_keystr(ptr, low_len);
    ptr += low_len;
    high.construct_from_keystr(ptr, high_len);
    ptr += high_len;
    chain.construct_from_keystr(ptr, chain_len);

    borrowed_btree_page_h bp(p);
    bp.compress(low, high, chain, true /* redo */);
}
